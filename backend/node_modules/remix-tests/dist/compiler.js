"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fileSystem_1 = __importDefault(require("./fileSystem"));
var async_1 = __importDefault(require("async"));
var path_1 = __importDefault(require("path"));
var RemixCompiler = require('remix-solidity').Compiler;
function regexIndexOf(inputString, regex, startpos) {
    if (startpos === void 0) { startpos = 0; }
    var indexOf = inputString.substring(startpos).search(regex);
    return (indexOf >= 0) ? (indexOf + (startpos)) : indexOf;
}
function writeTestAccountsContract(accounts) {
    var testAccountContract = require('../sol/tests_accounts.sol.js');
    var body = "address[" + accounts.length + "] memory accounts;";
    if (!accounts.length)
        body += ';';
    else {
        accounts.map(function (address, index) {
            body += "\naccounts[" + index + "] = " + address + ";\n";
        });
    }
    return testAccountContract.replace('>accounts<', body);
}
var userAgent = (typeof (navigator) !== 'undefined') && navigator.userAgent ? navigator.userAgent.toLowerCase() : '-';
var isBrowser = !(typeof (window) === 'undefined' || userAgent.indexOf(' electron/') > -1);
// TODO: replace this with remix's own compiler code
function compileFileOrFiles(filename, isDirectory, opts, cb) {
    var compiler;
    var accounts = opts.accounts || [];
    var sources = {
        'tests.sol': { content: require('../sol/tests.sol.js') },
        'remix_tests.sol': { content: require('../sol/tests.sol.js') },
        'remix_accounts.sol': { content: writeTestAccountsContract(accounts) }
    };
    var filepath = (isDirectory ? filename : path_1.default.dirname(filename));
    // TODO: for now assumes filepath dir contains all tests, later all this
    // should be replaced with remix's & browser solidity compiler code
    // This logic is wrong
    // We should only look into current file if a full file name with path is given
    // We should only walk through directory if a directory name is passed
    try {
        // walkSync only if it is a directory
        fileSystem_1.default.walkSync(filepath, function (foundpath) {
            // only process .sol files
            if (foundpath.split('.').pop() === 'sol') {
                var c = fileSystem_1.default.readFileSync(foundpath).toString();
                var s = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
                var includeTestLibs = '\nimport \'remix_tests.sol\';\n';
                if (foundpath.indexOf('_test.sol') > 0 && regexIndexOf(c, s) < 0) {
                    c = includeTestLibs.concat(c);
                }
                sources[foundpath] = { content: c };
            }
        });
    }
    catch (e) {
        throw e;
    }
    finally {
        async_1.default.waterfall([
            function loadCompiler(next) {
                compiler = new RemixCompiler();
                compiler.onInternalCompilerLoaded();
                // compiler.event.register('compilerLoaded', this, function (version) {
                next();
                // });
            },
            function doCompilation(next) {
                // @ts-ignore
                compiler.event.register('compilationFinished', this, function (success, data, source) {
                    next(null, data);
                });
                compiler.compile(sources, filepath);
            }
        ], function (err, result) {
            var errors = (result.errors || []).filter(function (e) { return e.type === 'Error' || e.severity === 'error'; });
            if (errors.length > 0) {
                if (!isBrowser)
                    require('signale').fatal(errors);
                return cb(new Error('errors compiling'));
            }
            cb(err, result.contracts);
        });
    }
}
exports.compileFileOrFiles = compileFileOrFiles;
function compileContractSources(sources, importFileCb, opts, cb) {
    var compiler, filepath;
    var accounts = opts.accounts || [];
    // Iterate over sources keys. Inject test libraries. Inject test library import statements.
    if (!('remix_tests.sol' in sources) && !('tests.sol' in sources)) {
        sources['remix_tests.sol'] = { content: require('../sol/tests.sol.js') };
        sources['remix_accounts.sol'] = { content: writeTestAccountsContract(accounts) };
    }
    var s = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
    var includeTestLibs = '\nimport \'remix_tests.sol\';\n';
    for (var file in sources) {
        var c = sources[file].content;
        if (file.indexOf('_test.sol') > 0 && c && regexIndexOf(c, s) < 0) {
            sources[file].content = includeTestLibs.concat(c);
        }
    }
    async_1.default.waterfall([
        function loadCompiler(next) {
            compiler = new RemixCompiler(importFileCb);
            compiler.onInternalCompilerLoaded();
            // compiler.event.register('compilerLoaded', this, function (version) {
            next();
            // });
        },
        function doCompilation(next) {
            // @ts-ignore
            compiler.event.register('compilationFinished', this, function (success, data, source) {
                next(null, data);
            });
            compiler.compile(sources, filepath);
        }
    ], function (err, result) {
        var errors = (result.errors || []).filter(function (e) { return e.type === 'Error' || e.severity === 'error'; });
        if (errors.length > 0) {
            if (!isBrowser)
                require('signale').fatal(errors);
            return cb(new Error('errors compiling'));
        }
        cb(err, result.contracts);
    });
}
exports.compileContractSources = compileContractSources;
//# sourceMappingURL=compiler.js.map